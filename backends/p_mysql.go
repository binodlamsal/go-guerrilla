package backends

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"io/ioutil"
	netmail "net/mail"
	"regexp"
	"strings"
	"time"

	"github.com/flashmob/go-guerrilla/mail"
	"github.com/go-sql-driver/mysql"

	"math/big"
	"net"
	"runtime/debug"

	"github.com/flashmob/go-guerrilla/response"
)

// ----------------------------------------------------------------------------------
// Processor Name: mysql (customized for EveryCloud by Eugene <eugene.mastervip@gmail.com>)
// ----------------------------------------------------------------------------------
// Description   : Saves the e.Data (email data) and e.DeliveryHeader together in mysql
//               : using the hash generated by the "hash" processor and stored in
//               : e.Hashes
// ----------------------------------------------------------------------------------
// Config Options: mail_table string - mysql table name
//               : mysql_db string - mysql database name
//               : mysql_host string - mysql host name, eg. 127.0.0.1
//               : mysql_pass string - mysql password
//               : mysql_user string - mysql username
//               : primary_mail_host string - primary host name
// --------------:-------------------------------------------------------------------
// Input         : e.Data
//               : e.DeliveryHeader generated by ParseHeader() processor
//               : e.MailFrom
//               : e.Subject - generated by by ParseHeader() processor
// ----------------------------------------------------------------------------------
// Output        : Sets e.QueuedId with the first item fromHashes[0]
// ----------------------------------------------------------------------------------
func init() {
	processors["mysql"] = func() Decorator {
		return MySql()
	}
}

const procMySQLReadTimeout = time.Second * 10
const procMySQLWriteTimeout = time.Second * 10

type MysqlProcessorConfig struct {
	MysqlTable           string `json:"mysql_mail_table"`
	MysqlGUIDLookupTable string `json:"mysql_guid_lookup_table"`
	MysqlBounceAddress   string `json:"mysql_bounce_address"`
	MysqlDB              string `json:"mysql_db"`
	MysqlHost            string `json:"mysql_host"`
	MysqlPass            string `json:"mysql_pass"`
	MysqlUser            string `json:"mysql_user"`
	PrimaryHost          string `json:"primary_mail_host"`
}

type MysqlProcessor struct {
	cache  stmtCache
	config *MysqlProcessorConfig
}

func (m *MysqlProcessor) connect(config *MysqlProcessorConfig) (*sql.DB, error) {
	var db *sql.DB
	var err error
	conf := mysql.Config{
		User:         config.MysqlUser,
		Passwd:       config.MysqlPass,
		DBName:       config.MysqlDB,
		Net:          "tcp",
		Addr:         config.MysqlHost,
		ReadTimeout:  procMySQLReadTimeout,
		WriteTimeout: procMySQLWriteTimeout,
		Params:       map[string]string{"collation": "utf8_general_ci", "parseTime": "1"},
	}
	if db, err = sql.Open("mysql", conf.FormatDSN()); err != nil {
		Log().Error("cannot open mysql", err)
		return nil, err
	}
	// do we have permission to access the table?
	_, err = db.Query("SELECT * FROM " + m.config.MysqlTable + " LIMIT 1")
	if err != nil {
		//Log().Error("cannot select table", err)
		return nil, err
	}
	Log().Info("connected to mysql on tcp ", config.MysqlHost)
	return db, err
}

// prepares the sql query with the number of rows that can be batched with it
func (g *MysqlProcessor) prepareInsertQuery(rows int, db *sql.DB) *sql.Stmt {
	if rows == 0 {
		panic("rows argument cannot be 0")
	}
	if g.cache[rows-1] != nil {
		return g.cache[rows-1]
	}
	sqlstr := "INSERT INTO " + g.config.MysqlTable + " "
	sqlstr += "(`nid`, `time_taken`, `datetime`, `guid`, `body`, `header`, `received_time`, `bounce`)"
	sqlstr += " VALUES "
	values := "(?, ?, ?, ?, ? , ?, ?, ?)"
	// add more rows
	comma := ""
	for i := 0; i < rows; i++ {
		sqlstr += comma + values
		if comma == "" {
			comma = ","
		}
	}
	stmt, sqlErr := db.Prepare(sqlstr)
	if sqlErr != nil {
		Log().WithError(sqlErr).Panic("failed while db.Prepare(INSERT...)")
	}
	// cache it
	g.cache[rows-1] = stmt
	return stmt
}

func (g *MysqlProcessor) doQuery(c int, db *sql.DB, insertStmt *sql.Stmt, vals *[]interface{}) (execErr error) {
	defer func() {
		if r := recover(); r != nil {
			Log().Error("Recovered form panic:", r, string(debug.Stack()))
			sum := 0
			for _, v := range *vals {
				if str, ok := v.(string); ok {
					sum = sum + len(str)
				}
			}
			Log().Errorf("panic while inserting query [%s] size:%d, err %v", r, sum, execErr)
			panic("query failed")
		}
	}()
	// prepare the query used to insert when rows reaches batchMax
	insertStmt = g.prepareInsertQuery(c, db)
	_, execErr = insertStmt.Exec(*vals...)
	if execErr != nil {
		Log().WithError(execErr).Error("There was a problem the insert")
	}
	return
}

func insertPing(db *sql.DB, table string, nid, timeTaken int, dateTime time.Time, guid, body, header string, receivedTime time.Time, bounce bool) error {
	sql := "INSERT INTO " + table
	sql += " (`nid`, `time_taken`, `datetime`, `guid`, `body`, `header`, `received_time`, `bounce`)"
	sql += " VALUES (?, ?, ?, ?, ? , ?, ?, ?)"

	_, err := db.Exec(sql, nid, timeTaken, dateTime, guid, body, header, receivedTime, bounce)

	if err != nil {
		return err
	}

	return nil
}

func updateLog(db *sql.DB, table string, seen int, guid string) error {
	sql := "UPDATE " + table + " SET seen=? WHERE guid=?"
	_, err := db.Exec(sql, seen, guid)

	if err != nil {
		return err
	}

	return nil
}

// for storing ip addresses in the ip_addr column
func (g *MysqlProcessor) ip2bint(ip string) *big.Int {
	bint := big.NewInt(0)
	addr := net.ParseIP(ip)
	if strings.Index(ip, "::") > 0 {
		bint.SetBytes(addr.To16())
	} else {
		bint.SetBytes(addr.To4())
	}
	return bint
}

func (g *MysqlProcessor) fillAddressFromHeader(e *mail.Envelope, headerKey string) string {
	if v, ok := e.Header[headerKey]; ok {
		addr, err := mail.NewAddress(v[0])
		if err != nil {
			return ""
		}
		return addr.String()
	}
	return ""
}

func MySql() Decorator {

	var config *MysqlProcessorConfig
	var vals []interface{}
	var db *sql.DB
	m := &MysqlProcessor{}

	// open the database connection (it will also check if we can select the table)
	Svc.AddInitializer(InitializeWith(func(backendConfig BackendConfig) error {
		configType := BaseConfig(&MysqlProcessorConfig{})
		bcfg, err := Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		config = bcfg.(*MysqlProcessorConfig)
		m.config = config
		db, err = m.connect(config)
		if err != nil {
			return err
		}
		return nil
	}))

	// shutdown will close the database connection
	Svc.AddShutdowner(ShutdownWith(func() error {
		if db != nil {
			return db.Close()
		}
		return nil
	}))

	return func(p Processor) Processor {
		return ProcessWith(func(e *mail.Envelope, task SelectTask) (Result, error) {
			if task == TaskSaveMail {
				var guid string
				var bounce, afterBounce bool
				var mid, seen int
				var senttime time.Time

				to := trimToLimit(strings.TrimSpace(e.RcptTo[0].String()), 255)

				if to == m.config.MysqlBounceAddress {
					bounce = true
					guid = extractGUID(e.String())
				} else {
					guid = extractGUID(e.Subject)
				}

				if guid == "" {
					Log().Warn("Could not extract GUID")
					return p.Process(e, task)
				}

				header, body, err := parseHeaderAndBody(e.String())

				if err != nil {
					Log().WithError(err).Errorf("Could not parse header and body of e-mail with GUID: %s", guid)
					return p.Process(e, task)
				}

				err = db.QueryRow("SELECT mid, senttime, seen"+
					" FROM "+m.config.MysqlGUIDLookupTable+
					" WHERE guid=?", guid).Scan(&mid, &senttime, &seen)

				if err == sql.ErrNoRows {
					Log().Infof("GUID %s not found", guid)
					return p.Process(e, task)
				}

				if err != nil {
					Log().WithError(err).Errorf("Failed to lookup GUID - %s", guid)
					return p.Process(e, task)
				}

				if seen == 1 {
					wasBounce := 0

					// check "bounce" flag with the matching GUID in "pings"
					err = db.QueryRow("SELECT bounce"+
						" FROM "+m.config.MysqlTable+
						" WHERE guid=?", guid).Scan(&wasBounce)

					// if nothing found then report this GUID as already seen
					if err == sql.ErrNoRows {
						Log().Infof("GUID %s is already seen", guid)
						return p.Process(e, task)
					}

					if err != nil {
						Log().WithError(err).Errorf("Failed to lookup GUID %s in %s table", guid, m.config.MysqlTable)
						return p.Process(e, task)
					}

					// if this GUID was previously registered as a bounce and currently it's not
					if wasBounce == 1 && bounce == false {
						// mark this message to be stored under the same GUID but as a non-bounce this time
						afterBounce = true
					} else {
						// otherwise report it as already seen
						Log().Infof("GUID %s is already seen", guid)
						return p.Process(e, task)
					}
				}

				delay := calculateDelay([]byte(e.String()))
				err = updateLog(db, m.config.MysqlGUIDLookupTable, 1, guid)

				if err != nil {
					Log().WithError(err).Errorf("Could not update %s table", m.config.MysqlGUIDLookupTable)
					return p.Process(e, task)
				}

				Log().Infof(`Updated "seen" flag for GUID %s`, guid)

				if len(e.Hashes) > 0 {
					e.QueuedId = e.Hashes[0]
				}

				for _ = range e.RcptTo {
					nid := mid
					timeTaken := delay
					datetime := senttime
					receivedTime := time.Now()

					// build the values for the query
					vals = []interface{}{} // clear the vals

					// do not store body of non-bounce messages
					if bounce == false {
						body = ""
					}

					err := insertPing(db, m.config.MysqlTable, nid, timeTaken, datetime, guid, body, header, receivedTime, bounce)

					if err != nil {
						return NewResult(fmt.Sprint("554 Error: could not save email")), StorageError
					}

					if afterBounce {
						Log().Infof("Message with GUID %s arrived after bounce - stored as a regular one", guid)
					}
				}

				// continue to the next Processor in the decorator chain
				return p.Process(e, task)
			} else if task == TaskValidateRcpt {
				// if you need to validate the e.Rcpt then change to:
				if len(e.RcptTo) > 0 {
					// since this is called each time a recipient is added
					// validate only the _last_ recipient that was appended
					last := e.RcptTo[len(e.RcptTo)-1]
					if len(last.User) > 255 {
						// return with an error
						return NewResult(response.Canned.FailRcptCmd), NoSuchUser
					}
				}
				// continue to the next processor
				return p.Process(e, task)
			} else {
				return p.Process(e, task)
			}
		})
	}
}

func parseRFC1123ZTime(s string) (time.Time, error) {
	m := regexp.MustCompile(`.*([A-Za-z_]{3}, \d+ [A-Za-z_]+ \d+ \d+:\d+:\d+ [-+]?\d+).*`).FindStringSubmatch(s)

	if m == nil {
		return time.Now(), errors.New("Could not find RFC1123Z time")
	}

	return netmail.ParseDate(m[1])
}

func calculateDelay(message []byte) (delay int) {
	msg, err := netmail.ReadMessage(bytes.NewReader(message))

	if err != nil {
		return
	}

	rcvdHdrs, ok := msg.Header["Received"]

	if !ok || len(rcvdHdrs) == 0 {
		return
	}

	lastRcvdTime, err := parseRFC1123ZTime(rcvdHdrs[0])

	if err != nil {
		return
	}

	sentTime, err := msg.Header.Date()

	if err != nil {
		return
	}

	return int(lastRcvdTime.Sub(sentTime).Seconds())
}

func parseHeaderAndBody(message string) (header, body string, err error) {
	m, err := netmail.ReadMessage(strings.NewReader(message))

	if err != nil {
		return
	}

	bodyBytes, err := ioutil.ReadAll(m.Body)

	if err != nil {
		return
	}

	body = string(bodyBytes)
	matches := regexp.MustCompile("(?s)^(.+?)\n\n").FindStringSubmatch(message)

	if matches != nil && len(matches) >= 2 {
		header = matches[1]
	}

	return
}

func extractGUID(text string) (guid string) {
	matches := regexp.MustCompile("guid:\\s*?(\\S+)\\s*?").FindStringSubmatch(text)

	if matches != nil {
		guid = matches[1]
	}

	return
}
